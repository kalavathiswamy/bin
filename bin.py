#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Admin-controlled Telegram bot with:
- Numeric /add <userId> and /remove <userId>, persisted in users.txt
- Authorization guard for all commands
- /start: shows basic server info
- /run [minutes]: starts a harmless long-running job with batching output
- /stop: stops the job
NOTE: This template is compliance-friendly and does NOT implement BIN/VBV features.
"""

import os
import asyncio
import psutil
from datetime import datetime, timedelta

from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
)

# ========= CONFIGURE THESE =========
BOT_TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
OWNER_ID = 1822845513                   # your Telegram numeric user ID (admin)
USERS_FILE = "users.txt"                # persisted approved users (one ID per line)

BATCH_SIZE = 10                         # how many items per message batch
TICK_SECONDS = 1                        # how often the worker produces an item
# ===================================

# Global runtime state
approved_users: set[str] = set()
worker_task: asyncio.Task | None = None
worker_should_run: bool = False


# ---------- Helpers: user storage & auth ----------

def load_users() -> set[str]:
    """Load approved user IDs (as strings) from USERS_FILE.
    Ensures OWNER_ID is always present."""
    users = set()
    if os.path.exists(USERS_FILE):
        with open(USERS_FILE, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if line.isdigit():
                    users.add(line)
    # Ensure owner is always authorized
    users.add(str(OWNER_ID))
    # Save back to guarantee presence on disk
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        for uid in sorted(users, key=int):
            f.write(uid + "\n")
    return users


def save_users(users: set[str]) -> None:
    with open(USERS_FILE, "w", encoding="utf-8") as f:
        for uid in sorted(users, key=int):
            f.write(uid + "\n")


def is_authorized(user_id: int) -> bool:
    return str(user_id) in approved_users


# ---------- Helpers: system info ----------

def server_status_text() -> str:
    cpu = psutil.cpu_percent(interval=0.5)
    mem = psutil.virtual_memory().percent
    disk = psutil.disk_usage("/").percent
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return (
        f"ğŸ¤– Bot Status (as of {now})\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ–¥ CPU: {cpu:.0f}%\n"
        f"ğŸ“¦ RAM: {mem:.0f}%\n"
        f"ğŸ’½ Disk: {disk:.0f}%\n"
        f"âœ… Ready.\n"
    )


# ---------- Worker (harmless placeholder) ----------

async def run_worker(chat_id: int, context: ContextTypes.DEFAULT_TYPE, minutes: int | None):
    """
    Harmless long-running job that simulates producing items and batching them into messages.
    - Produces one "item" every TICK_SECONDS.
    - Sends a batched message every BATCH_SIZE items.
    - If `minutes` is provided, auto-stops after that time.
    Replace the item generation block with your legitimate business logic.
    """
    global worker_should_run
    worker_should_run = True

    end_time = datetime.now() + timedelta(minutes=minutes) if minutes else None
    batch: list[str] = []
    sent_total = 0

    # Initial notice
    if minutes:
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"â–¶ï¸ Started job. It will auto-stop in {minutes} minute(s)."
        )
    else:
        await context.bot.send_message(
            chat_id=chat_id,
            text="â–¶ï¸ Started job. It will run until you send /stop."
        )

    try:
        while worker_should_run:
            # Auto-stop by timer
            if end_time and datetime.now() >= end_time:
                break

            # ---- Replace this block with your legitimate work ----
            # Simulate producing a harmless "item"
            item_number = sent_total + 1
            item_text = (
                "ğŸ“¦ Item ready!\n\n"
                f"â€¢ ID: {item_number}\n"
                f"â€¢ Note: Placeholder result\n"
                "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n"
                "Generated by Admin Bot"
            )
            # ------------------------------------------------------

            batch.append(item_text)
            sent_total += 1

            # Send a batch every BATCH_SIZE items
            if len(batch) >= BATCH_SIZE:
                await context.bot.send_message(chat_id=chat_id, text="\n\n".join(batch))
                batch.clear()

            await asyncio.sleep(TICK_SECONDS)

        # Flush any remaining items
        if batch:
            await context.bot.send_message(chat_id=chat_id, text="\n\n".join(batch))

    finally:
        worker_should_run = False
        await context.bot.send_message(
            chat_id=chat_id,
            text=f"â¹ï¸ Job stopped. Total items: {sent_total}"
        )


# ---------- Commands ----------

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_authorized(user.id):
        return await update.message.reply_text("ğŸš« You are not authorized to use this bot.")
    await update.message.reply_text(
        "ğŸ‘‹ Hello! Admin Bot is online.\n\n" + server_status_text() +
        "\nCommands:\n"
        "â€¢ /add <userId> â€” approve a user (admin only)\n"
        "â€¢ /remove <userId> â€” remove a user (admin only)\n"
        "â€¢ /run [minutes] â€” start a job (approved users)\n"
        "â€¢ /stop â€” stop the running job"
    )


async def cmd_add(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id != OWNER_ID:
        return await update.message.reply_text("ğŸš« Only the owner can add users.")

    if not context.args:
        return await update.message.reply_text("âš ï¸ Usage: /add <numeric_user_id>")

    uid = context.args[0].strip()
    if not uid.isdigit():
        return await update.message.reply_text("âš ï¸ User ID must be numeric.")

    if uid in approved_users:
        return await update.message.reply_text(f"â„¹ï¸ {uid} is already approved.")

    approved_users.add(uid)
    save_users(approved_users)
    await update.message.reply_text(f"âœ… User {uid} approved and saved to users.txt.")


async def cmd_remove(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id != OWNER_ID:
        return await update.message.reply_text("ğŸš« Only the owner can remove users.")

    if not context.args:
        return await update.message.reply_text("âš ï¸ Usage: /remove <numeric_user_id>")

    uid = context.args[0].strip()
    if not uid.isdigit():
        return await update.message.reply_text("âš ï¸ User ID must be numeric.")

    if uid == str(OWNER_ID):
        return await update.message.reply_text("âš ï¸ You cannot remove the owner.")

    if uid in approved_users:
        approved_users.remove(uid)
        save_users(approved_users)
        return await update.message.reply_text(f"ğŸ—‘ï¸ User {uid} removed.")
    else:
        return await update.message.reply_text(f"âŒ User {uid} not found.")


async def cmd_run(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start the harmless worker. Usage: /run [minutes]"""
    global worker_task, worker_should_run

    user = update.effective_user
    chat_id = update.effective_chat.id
    if not is_authorized(user.id):
        return await update.message.reply_text("ğŸš« You are not authorized to use this bot.")

    if worker_task and not worker_task.done() and worker_should_run:
        return await update.message.reply_text("âš ï¸ A job is already running. Use /stop first.")

    # Parse optional minutes
    minutes = None
    if context.args:
        arg = context.args[0].strip()
        if not arg.isdigit() or int(arg) <= 0:
            return await update.message.reply_text("âš ï¸ Minutes must be a positive integer. Example: /run 10")
        minutes = int(arg)

    # Start the worker
    worker_task = asyncio.create_task(run_worker(chat_id, context, minutes))


async def cmd_stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Stop the worker if running."""
    global worker_task, worker_should_run

    user = update.effective_user
    if not is_authorized(user.id):
        return await update.message.reply_text("ğŸš« You are not authorized to use this bot.")

    if worker_task and not worker_task.done() and worker_should_run:
        worker_should_run = False
        await update.message.reply_text("ğŸ›‘ Stopping the jobâ€¦")
        # Let the worker finalize gracefully
        try:
            await asyncio.wait_for(worker_task, timeout=10)
        except asyncio.TimeoutError:
            worker_task.cancel()
        worker_task = None
    else:
        await update.message.reply_text("â„¹ï¸ No job is currently running.")


# ---------- Main ----------

def main():
    global approved_users
    approved_users = load_users()

    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("add", cmd_add))
    app.add_handler(CommandHandler("remove", cmd_remove))
    app.add_handler(CommandHandler("run", cmd_run))
    app.add_handler(CommandHandler("stop", cmd_stop))

    print("ğŸ¤– Admin Bot is runningâ€¦")
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
